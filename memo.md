N * Nの盤面
N = 20 で固定

鬼がN体、福がN体

1回の操作で次ができる
行を左右にシフトする、端はこぼれる
列を上下にシフトする、端はこぼれる

操作は4N^2回まで、操作回数をなるべく少なくする

目標
- 盤面上の鬼をなるべく多く取り除く
- 福が取り除かれる個数をなるべく少なくする

盤面の状態
x: 鬼
o: 福
.: 無し

https://img.atcoder.jp/ahc042/cnhLtdRT.html
ビジュアライザで手動で遊べるようになってる

初期状態で鬼が存在する各マスについて、次のいずれかの条件を満たすことが保証されている。
これにより、盤面上のすべての鬼を取り除き、すべての福を残すような、4N^2 手以下の操作手順が必ず存在する。
- 同じ列の上方向にあるすべてのマスに福が存在しない。
- 同じ列の下方向にあるすべてのマスに福が存在しない。
- 同じ行の左方向にあるすべてのマスに福が存在しない。
- 同じ行の右方向にあるすべてのマスに福が存在しない。

得点はなんかクリアすると3000点くらいはいくかな？
鬼が残ってる状態だと1500点くらいだからがんばってクリアしたほうがいい
全クリしたときのスコアが 8N^2 - T (T=操作回数) で8N^2 = 3200だからまあ200手くらいでクリアできたら3000くらいか

一回の操作で落とせる鬼は１体までなので、最低でも20手は必要

とりあえず簡単な解を一個だしたい、４時間しかないし…

初期状態では鬼はどっかから必ず福を落とさずに落とせることは保証されてるけど、
落とすために動かしたときに鬼の四方に福がいるっていう状態は必ず起こるな

あー、でもあれか
一回落として盤面を元に戻せば必ずまた初期状態（から鬼が1体減った状態）になるから、
鬼を１体落とす→初期盤面に戻す→鬼を１体落とす→…
ってやっていけば鬼を全部落とせてかつ福が１体も落ちないようにはできるか

んで、１体落として戻す操作の手数がだいたい10*2=20手だから
20*20=400手くらいではクリアが可能
いちいち初期盤面に戻すっていうのが効率悪いけど、一応これを最初の解とするか

で、まぁこれを改善していく～みたいな感じにする？
まあそれもいろいろやり方はあるんだけど…

実装的に一番楽そうなのは
- 左上から順に一体ずつ鬼を見ていって、それを最短距離で落とせる操作を生成、そしてその逆操作で盤面を戻す
- これを繰り返す
かなあ

もうちょっと効率よくやろうとすると
- 行ごと（列ごと）に見ていって、可能な限り左か右に動かして鬼をたくさん落としてから元に戻す
- これを盤面から鬼がいなくなるまで繰り返す

盤面を戻す操作は、操作対象の列に福がいなければやらなくていいので
最初に鬼しかいない列を探して全部そこは落としておけばちょっと効率はいいかもしれない

もう少しいうと操作対象の列について、鬼を落とした後の福の位置が他の鬼の脱出経路をふさぐ位置になっていなければOK

なるべく鬼をどっかの列にまとめてからガーッて落とすと効率良さそうな気はするが、そこまでできるかなあ…

実装の方針

BoardはN*Nのi32の２次元配列で
-1:鬼, 1:福, 0:無し
みたいにする…？
enum型使うか、RoomStateでOni, Fuku, Vacantで
